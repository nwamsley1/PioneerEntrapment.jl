var documenterSearchIndex = {"docs":
[{"location":"fast_paired_efdr/#Fast-Paired-EFDR:-How-it-Works-and-Behavioral-Equivalence","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"This note explains an O(n log n + K) algorithm for the paired entrapment EFDR that matches the current O(n^2) implementation. It summarizes how counts are accumulated across score cutoffs and why the resulting EFDR curve is identical (after the same monotone post-processing) to the quadratic method.","category":"page"},{"location":"fast_paired_efdr/#Background","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Background","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"For each entity, we have:","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"e: entrap score\nt: original target score (may be missing/NA)\nlabel: 0 for original target rows, 1 for entrap rows (we only need t and e for counting)","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"At a threshold s, the paired EFDR numerator is:","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"n_e(s): entraps with e ≥ s\nn_est(s): entraps with e ≥ s and (t < s or t is NA)\nn_ets(s): both discovered and e > t among pairs with e ≥ s and t ≥ s","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"The denominator is n_targets(s) + n_e(s) where n_targets(s) = #(t ≥ s).","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"EFDR(s) = (ne + nest + 2*nets) / (ntargets + n_e)","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"The O(n^2) reference scans the sorted list and recomputes these counts at every step. The fast method pre-aggregates over a discrete set of ascending cutoffs and uses difference arrays to recover counts for all s in a single pass.","category":"page"},{"location":"fast_paired_efdr/#Cutoffs-and-Indexing","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Cutoffs and Indexing","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Choose ascending cutoffs cuts[1..K]. Two sensible choices:","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"targets_only: cuts = sort(unique(t[!missing]))\nall: cuts = sort(unique(t ∪ e))","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"For any value x, define idx(x) = max{ j | cuts[j] ≤ x } (0 if x < cuts[1]). With this, x ≥ cuts[j] iff idx(x) ≥ j.","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"We compute index vectors:","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"idx_t_all[i] = idx(t[i]) or missing\nidx_e_all[i] = idx(e[i]) or missing","category":"page"},{"location":"fast_paired_efdr/#Suffix-Sums-for-n*targets-and-n*e","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Suffix Sums for ntargets and ne","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Let tab(idx_vec) produce a length-K histogram of 1..K indices (ignore 0/missing). Then:","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"T_asc = suffix_sum(tab(idx_t)) equals n_targets(s) for each ascending cutoff.\nE_asc = suffix_sum(tab(idx_e)) equals n_e(s) for each ascending cutoff.","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Suffix sum converts counts-at-exact-cut into counts-above-or-equal-to-cut.","category":"page"},{"location":"fast_paired_efdr/#n_ets(s):-entrap-outranks-target","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"n_ets(s): entrap outranks target","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Among rows where both scores are present and e > t, let m_i = min(idx_t[i], idx_e[i]). Each such pair contributes +1 to n_ets(s) for all cuts ≤ m_i. Thus:","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"histogram the m_i (ignoring 0)\nsuffix sum that histogram to obtain n_ets(s) at each ascending cutoff.","category":"page"},{"location":"fast_paired_efdr/#n_est(s):-entrap-s-and-(target-s-or-target-is-NA)","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"n_est(s): entrap ≥ s and (target < s or target is NA)","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Think in terms of ranges on the ascending index j (cut position):","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"If t is NA and idx_e = k > 0, the row contributes +1 for cuts j = 1..k.\nIf both present with idx_t = a, idx_e = b, and a+1 ≤ j ≤ b, it contributes +1 for those j.","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"We accumulate these via a difference array diff[1..K+1]:","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"For each segment [start..end], do diff[start] += 1; diff[end+1] -= 1.\nThen cumsum(diff)[1:K] yields EST_asc.","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"This turns many range updates into O(K) work overall.","category":"page"},{"location":"fast_paired_efdr/#EFDR-and-Mapping-Back","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"EFDR and Mapping Back","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"With T_asc, E_asc, EST_asc, ETS_asc for ascending cuts, we compute efdr_asc. To report EFDR per row (for plotting and API compatibility), we map each item to its entrap index idx_e_all[i] and take efdr_asc[idx_e_all[i]]. Finally, we apply the same monotone correction used by the quadratic code over the sort order (by (-score, qval)).","category":"page"},{"location":"fast_paired_efdr/#Should-the-Fast-Method-Match-the-Quadratic-Method?","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Should the Fast Method Match the Quadratic Method?","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Yes, provided that:","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"The same notion of threshold s is used (we evaluate at cutoffs consistent with the quadratic’s traversal), and\nThe same monotone post-processing (reverse cumulative minimum over the traversal order) is applied.","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Intuitively, both methods evaluate the same counts but the fast method reorganizes the computation: rather than recomputing counts at each step, it builds them once over all cutoffs via histograms, suffix sums, and a difference array. The EFDR curve (as a function of s) is identical. Ties and traversal order are reconciled by applying the same monotonicity correction.","category":"page"},{"location":"fast_paired_efdr/#Edge-Cases","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Edge Cases","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Missing target score: handled in n_est by giving full range [1..idx_e].\nidx = 0 (score below the first cutoff): contributes nothing to counts at positive cuts.\nEmpty cut list: return all-zero EFDR.","category":"page"},{"location":"fast_paired_efdr/#Complexity","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Complexity","text":"","category":"section"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"Building cuts: O(n log n) for sorting unique scores.\nTabulation/suffix sums/difference array: O(n + K)\nMapping per-row EFDR and monotone pass: O(n)","category":"page"},{"location":"fast_paired_efdr/","page":"Fast Paired EFDR: How it Works and Behavioral Equivalence","title":"Fast Paired EFDR: How it Works and Behavioral Equivalence","text":"This replaces the O(n^2) reference with O(n log n + K), where K is the number of unique cutoffs.","category":"page"},{"location":"entrapment_computation/#Entrapment-Pairing-and-EFDR-Computation","page":"Entrapment EFDR","title":"Entrapment Pairing and EFDR Computation","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"This page explains how PioneerEntrapment.jl defines target/entrapment groupings, assigns pair identifiers, derives “original target” scores, and computes empirical FDR (EFDR) using both the Combined and Paired approaches.","category":"page"},{"location":"entrapment_computation/#Key-Concepts","page":"Entrapment EFDR","title":"Key Concepts","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Target vs Entrapment: Original targets are labeled with 0 and entrapments with non-zero integers.\nPrecursor level: :entrapment_group_id (from the spectral library).\nProtein level: :entrap_id (from the protein results/library).\nEntrapment Pair: A stable identifier that groups an original target with its corresponding entrapment analog(s). Pairs allow paired EFDR to reason about target–entrapment relationships within the same biological entity.\nOriginal Target Score: For a given entrapment row, the score of its corresponding original target (its pair-mate) at the same file (and species, for proteins). This is materialized in columns named like \"<score>_original_target\".","category":"page"},{"location":"entrapment_computation/#How-Pairing-Is-Determined","page":"Entrapment EFDR","title":"How Pairing Is Determined","text":"","category":"section"},{"location":"entrapment_computation/#Precursor-Level-Pairs","page":"Entrapment EFDR","title":"Precursor-Level Pairs","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"The spectral library carries a precomputed :entrapment_pair_id per precursor (e.g., peptide ion). That pairing is established during library preparation and ensures that each entrapment has a unique target counterpart.\nUse add_entrap_pair_ids!(prec_results, library_precursors) to attach the precomputed :entrapment_pair_id onto the results table via :precursor_idx.\nOnce :entrapment_pair_id is present, add_original_target_scores! can compute \"<score>_original_target\" by locating the original target within the same pair (and file) and copying its score.","category":"page"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Notes","category":"page"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Missing partners: If a paired original target does not exist in a file, the \"<score>_original_target\" value is set to -1.0 for that row.\nModifications: Utilities like getModKey normalize modification annotations for grouping during library construction; however, pairing at runtime simply consumes :entrapment_pair_id from the library.","category":"page"},{"location":"entrapment_computation/#Protein-Level-Pairs","page":"Entrapment EFDR","title":"Protein-Level Pairs","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"When :entrapment_pair_id is not present at the protein level, use assign_protein_entrapment_pairs! to create it from a table that has :protein and :entrap_id.\nAlgorithm (per unique protein):\nSplit rows into original targets (entrap_id == 0) and entrapment groups (entrap_id != 0).\nIf a protein lacks either a target or an entrapment, it is skipped.\nFor each target row, assign a new pair ID and then round‑robin assign that same ID to exactly one row from each entrapment group. Round‑robin avoids bias when groups have unequal counts.\nOnce assigned, propagate :entrapment_pair_id to results via add_protein_entrap_pair_ids! if needed (maps by :protein).\nUse add_original_target_protein_scores! to populate \"<score>_original_target\" at the protein level. The mapping keys on (file, species, protein) if :species is present, otherwise (file, \"\", protein).\nUse add_original_target_protein_scores! to populate \"<score>_original_target\" at the protein level. The mapping uses (file, species, protein_key) where protein_key is the first member of the protein group name (i.e., split(protein,';')[1]). If :species is absent, the key is (file, \"\", protein_key).","category":"page"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Notes","category":"page"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Duplicate targets: If a file/species/protein combination contains multiple targets, an error is thrown to prevent ambiguous mapping.\nMissing partners: If the original target is absent, the \"<score>_original_target\" value is set to -1.0.","category":"page"},{"location":"entrapment_computation/#EFDR-Methods","page":"Entrapment EFDR","title":"EFDR Methods","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Two EFDR estimators are supported. Both operate on an ordering defined by (-score, qval) (descending score, then ascending q-value to break ties), and both enforce monotonicity of EFDR along that order.","category":"page"},{"location":"entrapment_computation/#Combined-EFDR","page":"Entrapment EFDR","title":"Combined EFDR","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Tracks cumulative counts:\nNτ: number of targets observed up to a cutoff.\nNϵ: number of entrapments observed up to a cutoff.\nEFDR estimate: (Nϵ * (1 + 1/r)) / (Nϵ + Nτ), typically with r = 1.0 for a balanced design.\nImplemented by constructing a CombinedEFDR method and calling calculate_efdr.","category":"page"},{"location":"entrapment_computation/#Paired-EFDR","page":"Entrapment EFDR","title":"Paired EFDR","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Uses original target scores to refine the numerator with additional terms that reflect within‑pair behavior:\nNϵsτ: entrapments that pass the entrapment cut but whose target is below the target cut (or missing).\nNϵτs: entrapments that exceed their target even when the target passes the cut.\nEFDR estimate: (Nϵ + Nϵsτ + 2·Nϵτs) / (Nϵ + Nτ), clipped to [0, 1].\nImplemented by constructing a PairedEFDR method and calling calculate_efdr.\nExact computation can be O(n²); a sampling stride is supported for speed.\nSee also calculate_efdr_fast(::PairedEFDR) for an O(n log n + K) aggregated version.","category":"page"},{"location":"entrapment_computation/#Global-Best-Rows-Across-Files","page":"Entrapment EFDR","title":"Global Best Rows Across Files","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"To create a single row per entity (precursor or protein), choose the best score across files:","category":"page"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Precursors: create_global_results_df(prec_results; score_col=:global_prob) groups by :precursor_idx.\nProteins: create_global_protein_results_df(protein_results; score_col=:global_pg_score) groups by :species (if present), :protein, and :entrap_id (if present), so that target and each entrapment group select their own best row.","category":"page"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Returned rows carry :ms_file_idx = 0 or :file_name = \"global\" to indicate a cross-file selection.","category":"page"},{"location":"entrapment_computation/#Practical-Workflow","page":"Entrapment EFDR","title":"Practical Workflow","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Precursor EFDR\nAttach :entrapment_pair_id with add_entrap_pair_ids!.\nCompute original targets with add_original_target_scores! for desired score columns.\nAdd EFDR columns via add_efdr_columns! (Combined always; Paired requires \"<score>_original_target\").\nProtein EFDR\nEnsure :entrapment_pair_id exists: run assign_protein_entrapment_pairs! if necessary, or propagate from a library using add_protein_entrap_pair_ids!.\nCompute original targets with add_original_target_protein_scores!.\nRun add_protein_efdr_columns! to attach EFDR columns.","category":"page"},{"location":"entrapment_computation/#Design-Choices-and-Edge-Cases","page":"Entrapment EFDR","title":"Design Choices & Edge Cases","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Round‑robin pairing at the protein level ensures a fair distribution of pairs when entrapment groups have unequal number of rows.\nMissing partners are explicitly marked with -1.0 in \"<score>_original_target\" columns; Paired EFDR treats these as target‑absent cases.\nEFDR curves are post‑processed to be monotonically nonincreasing along the (-score, qval) order.\nThe ratio r defaults to 1.0 but can be tuned if the number of available target vs entrapment entities differs.","category":"page"},{"location":"entrapment_computation/#References-(Code-Pointers)","page":"Entrapment EFDR","title":"References (Code Pointers)","text":"","category":"section"},{"location":"entrapment_computation/","page":"Entrapment EFDR","title":"Entrapment EFDR","text":"Pairing\nassign_protein_entrapment_pairs! (protein): src/core/protein_entrapment_pairing.jl\nadd_entrap_pair_ids! (precursor): src/core/entrapment_pairing.jl\nOriginal targets\nPrecursors: add_original_target_scores! in src/core/scoring.jl\nProteins: add_original_target_protein_scores! in src/core/protein_scoring.jl\nEFDR methods\nCombinedEFDR, PairedEFDR, and add_efdr_columns!: src/core/efdr_methods.jl\nFast Paired EFDR: calculate_efdr_fast in src/core/paired_fast.jl","category":"page"},{"location":"#PioneerEntrapment.jl","page":"Home","title":"PioneerEntrapment.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Entrapment-based empirical FDR analysis for DIA proteomics.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/nwamsley1/PioneerEntrapment.jl","category":"page"},{"location":"#Julia-REPL-(quick-start)","page":"Home","title":"Julia REPL (quick start)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using PioneerEntrapment\nrun_efdr_analysis(\"precursors.arrow\", \"library.arrow\"; output_dir=\"out\")\nrun_protein_efdr_analysis(\"proteins.arrow\"; output_dir=\"out\")\nrun_both_analyses(; precursor_results_path=\"precursors.arrow\", library_precursors_path=\"library.arrow\", protein_results_path=\"proteins.arrow\", output_dir=\"out\")","category":"page"},{"location":"#CLI-(single-run)","page":"Home","title":"CLI (single run)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pioneer-entrapment --mode precursor --precursor-results prec.arrow --library lib.arrow --outdir out\npioneer-entrapment --mode protein --protein-results protein.arrow --outdir out\npioneer-entrapment --mode both --precursor-results prec.arrow --library lib.arrow --protein-results protein.arrow --outdir out","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"run_efdr_analysis\nrun_protein_efdr_analysis\nrun_both_analyses","category":"page"},{"location":"#PioneerEntrapment._get_required_lib_columns","page":"Home","title":"PioneerEntrapment._get_required_lib_columns","text":"_get_required_lib_columns(entrap_species, need_mod_key) -> Vector{Symbol}\n\nDetermine required columns for loading library precursors.\n\nArguments\n\nentrap_species: Optional species name for species-based entrapment\nneedmodkey: Whether mod_key column needs to be loaded (for computing if missing)\n\nReturns\n\nVector of required column names\n\n\n\n\n\n","category":"function"},{"location":"#PioneerEntrapment._get_required_prec_columns","page":"Home","title":"PioneerEntrapment._get_required_prec_columns","text":"_get_required_prec_columns(score_qval_pairs, has_file_idx, entrap_species) -> Vector{Symbol}\n\nDetermine required columns for loading precursor results.\n\nArguments\n\nscoreqvalpairs: Vector of (scorecol, qvalcol) tuples\nhasfileidx: Whether msfileidx is available (use :file_name as fallback if false)\nentrap_species: Optional species name for species-based entrapment\n\nReturns\n\nVector of required column names\n\n\n\n\n\n","category":"function"},{"location":"#PioneerEntrapment._get_required_protein_columns","page":"Home","title":"PioneerEntrapment._get_required_protein_columns","text":"_get_required_protein_columns(score_qval_pairs, has_file_idx, entrap_species) -> Vector{Symbol}\n\nDetermine required columns for loading protein results.\n\nArguments\n\nscoreqvalpairs: Vector of (scorecol, qvalcol) tuples\nhasfileidx: Whether msfileidx is available (use :file_name as fallback if false)\nentrap_species: Optional species name for species-based entrapment\n\nReturns\n\nVector of required column names\n\n\n\n\n\n","category":"function"},{"location":"#PioneerEntrapment._load_table-Tuple{AbstractString}","page":"Home","title":"PioneerEntrapment._load_table","text":"Load a tabular file into a DataFrame. Supports Arrow/Feather (.arrow, .feather) and delimited text (.csv, .tsv, .txt). Also accepts a directory path (e.g., a .poin folder) and will locate a suitable table inside, preferring precursors_table.arrow, then any .arrow/.feather, then .tsv/.csv. Falls back to trying Arrow, then CSV regardless of extension.\n\nArguments\n\npath: Path to file or directory\ncolumns: Optional vector of column names to load (Arrow only). If nothing, loads all columns.         For selective loading (faster, less memory), pass e.g. [:precursor_idx, :target, :prec_prob].\n\nPerformance Note\n\nSelective column loading can be 100-150x faster for large Arrow files.\nExample: Loading 7 columns vs all 42 reduces time from 11.5s to 0.13s and memory from 180MB to 14MB.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.add_efdr_columns!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.add_efdr_columns!","text":"add_efdr_columns!(df, library_precursors; method_types=[CombinedEFDR,PairedEFDR], score_qval_pairs=[(:score,:qval)], r=1.0, paired_stride=5, use_fast_paired=true, entrap_labels_override=nothing) -> Nothing\n\nCompute EFDR columns for one or more (score, qval) pairs and attach them to a precursor-level DataFrame. If :<score>_original_target is absent, PairedEFDR is skipped for that score; CombinedEFDR falls back to score only.\n\nRequired columns\n\ndf: :precursor_idx, each score and qval used\nlibraryprecursors: `:entrapmentgroupidunlessentraplabels_override` provided\n\nParameters\n\nusefastpaired: If true (default), use fast O(n log n) implementation for PairedEFDR. If false, use standard O(n²) implementation.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.add_entrap_pair_ids!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.add_entrap_pair_ids!","text":"add_entrap_pair_ids!(prec_results::DataFrame, library_precursors::DataFrame) -> Nothing\n\nAttach precomputed entrapment pair IDs to a precursor-level results table.\n\nThe library_precursors table must contain :entrapment_pair_id (precomputed during library construction). This function copies that ID onto each row of prec_results by indexing via :precursor_idx.\n\nRequired columns\n\nprecresults: `:precursoridx`\nlibraryprecursors: `:entrapmentpair_id`\n\nSide effects\n\nAdds a :entrapment_pair_id::Union{Missing,UInt32} column to prec_results.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.add_original_target_protein_scores!-Tuple{DataFrames.DataFrame, Vector{Symbol}}","page":"Home","title":"PioneerEntrapment.add_original_target_protein_scores!","text":"add_original_target_protein_scores!(protein_results::DataFrame, score_cols::Vector{Symbol}) -> Nothing\n\nVectorized overload to compute original target columns for multiple score fields.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.add_original_target_protein_scores!-Tuple{DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.add_original_target_protein_scores!","text":"add_original_target_protein_scores!(protein_results::DataFrame; score_col=:pg_score) -> Nothing\n\nAdd a \"<score>_original_target\" column capturing, for each protein row, the score of the original target protein (entrap_id == 0) with the same file and species. For protein group identifiers that contain multiple entries separated by ;, the first entry (i.e., split(protein,';')[1]) is used as the group key so targets/entrapments match on the same canonical ID.\n\nIf the row itself is the original target, its own score is used. If there is no matching original target, the value is set to -1.0f0.\n\nRequired columns\n\nproteinresults: :protein, `:entrapid,:species,scorecol, and either:msfileidxor:filename`.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.add_original_target_scores!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.add_original_target_scores!","text":"add_original_target_scores!(prec_results::DataFrame, library_precursors::DataFrame; score_col=:score) -> Nothing\n\nAttach the original target score for each row based on entrapment pairing.\n\nFor each row in prec_results with :entrapment_pair_id, we determine the original target (the library entry with :entrapment_group_id == 0) within the same pair and MS file, and write that score to a new column Symbol(String(score_col) * \"_original_target\").\n\nWhen a row itself is the original target, the new column equals its own score. When the original target does not exist (e.g., missing partner), the value is set to -1.0 to flag absence.\n\nRequired columns\n\nprecresults: `:entrapmentpairid,:precursoridx,scorecol, and either:msfile_idx` or implicitly use 0\nlibraryprecursors: `:entrapmentgroup_id`\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.add_protein_efdr_columns!-Tuple{DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.add_protein_efdr_columns!","text":"add_protein_efdr_columns!(protein_results; method_types=[CombinedEFDR,PairedEFDR], score_qval_pairs=[(:pg_score,:qval)], r=1.0, paired_stride=5, use_fast_paired=true, entrap_labels_override=nothing) -> Nothing\n\nCompute EFDR for protein-level results and attach columns named like \"<score>_combined_efdr\" and \"<score>_paired_efdr\".\n\nIf <score>_original_target is missing, PairedEFDR for that score is skipped. When entrap_labels_override == nothing, :entrap_id is used to label target vs entrapment proteins (0 vs non-zero).\n\nParameters\n\nusefastpaired: If true (default), use fast O(n log n) implementation for PairedEFDR. If false, use standard O(n²) implementation.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.add_protein_entrap_pair_ids!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.add_protein_entrap_pair_ids!","text":"add_protein_entrap_pair_ids!(protein_results::DataFrame, protein_library::DataFrame) -> Nothing\n\nPropagate preassigned :entrapment_pair_id from a protein library table to a results table.\n\nThis maps on :protein. If the library contains multiple rows per protein, the first encountered :entrapment_pair_id is used.\n\nRequired columns\n\nprotein_results: :protein\nproteinlibrary: :protein, `:entrapmentpair_id`\n\nSide effects\n\nAdds :entrapment_pair_id column to protein_results.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.assign_protein_entrapment_pairs!-Tuple{DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.assign_protein_entrapment_pairs!","text":"assign_protein_entrapment_pairs!(df::DataFrame) -> Nothing\n\nAssign a stable :entrapment_pair_id for each protein across target and entrapment entries.\n\nRules (per unique :protein):\n\nSplit rows by :entrap_id == 0 (original target) vs :entrap_id != 0 (entrapment groups).\nIf a protein lacks at least one target AND one entrapment, it is skipped.\nFor each target row, assign a new pair ID and round‑robin assign that same ID to exactly one row from each entrapment group for that protein. This avoids bias when there are unequal numbers of entries per group.\n\nRequired columns\n\ndf: :protein, :entrap_id\n\nSide effects\n\nAdds/fills :entrapment_pair_id::Union{Missing,UInt32} in df.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.calculate_efdr-Tuple{CombinedEFDR}","page":"Home","title":"PioneerEntrapment.calculate_efdr","text":"calculate_efdr(method::CombinedEFDR) -> Vector{Float64}\n\nCompute empirical FDR for the Combined method by scanning the order defined by (-score, qval) and applying the ratio-based estimator to cumulative counts of entrapments and targets. Enforces monotonicity over the sort order.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.calculate_efdr-Tuple{PairedEFDR}","page":"Home","title":"PioneerEntrapment.calculate_efdr","text":"calculate_efdr(method::PairedEFDR; stride::Int=5) -> Vector{Float64}\n\nEstimate EFDR for the Paired method. For efficiency, computes EFDR at sampled positions 1:stride:n along the order defined by (-score, qval) and fills forward between checkpoints, then enforces monotonicity.\n\nCounts per checkpoint at score cut s:\n\nNτ: targets ≥ s\nNϵ: entrapments ≥ s\nNϵsτ: entrapments ≥ s with target < s (or missing)\nNϵτs: entrapments > target with target ≥ s\n\nEFDR(s) = (Nϵ + Nϵsτ + 2·Nϵτs) / (Nϵ + Nτ), capped to [0,1].\n\nSet stride=1 for the exact O(n²) computation.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.calculate_efdr_fast-Tuple{PairedEFDR}","page":"Home","title":"PioneerEntrapment.calculate_efdr_fast","text":"calculate_efdr_fast(method::PairedEFDR; cuts_mode::Symbol=:targets_only)\n\nCompute paired EFDR using an O(n log n + K) approach that aggregates counts over score cutoffs rather than scanning quadratically per threshold.\n\ncuts_mode controls which unique score cutoffs are used:\n\n:targetsonly => unique(t) where t = originaltarget_score (non-missing)\n:all          => unique union of t and e (entrap scores)\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.calculate_protein_efdr_calibration_error-Tuple{DataFrames.DataFrame, Symbol, Symbol}","page":"Home","title":"PioneerEntrapment.calculate_protein_efdr_calibration_error","text":"calculate_protein_efdr_calibration_error(protein_results, qval_col, efdr_col; entrap_labels_override=nothing) -> (DataFrame, Float64)\n\nCompute realized FDR across thresholds 0.001:0.001:0.1 for a given EFDR column and return a table with the absolute error vs the nominal threshold, along with the mean absolute error.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.compare_protein_efdr_methods-Tuple{DataFrames.DataFrame, Symbol, Symbol}","page":"Home","title":"PioneerEntrapment.compare_protein_efdr_methods","text":"compare_protein_efdr_methods(protein_results, qval_col, score_col; entrap_labels_override=nothing, include_paired=true) -> DataFrame\n\nSummarize method calibration by comparing selections at a set of EFDR/q-value thresholds against the actual entrapment fraction.\n\nReturns one row per threshold with counts and realized FDR for q-value-based selection, combined EFDR, and optionally paired EFDR.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.create_global_protein_results_df-Tuple{DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.create_global_protein_results_df","text":"create_global_protein_results_df(protein_results::DataFrame; score_col::Symbol=:global_pg_score) -> DataFrame\n\nSelect the best row across files per grouping of (species?, protein, entrap_id?).\n\nGroups by :species if present, always by :protein, and by :entrap_id if present.\nFor each group, picks the row with the maximum score_col.\nIf :ms_file_idx exists, sets it to 0 for returned rows; otherwise assigns :file_name => \"global\".\n\nNotes\n\nDecoys: upstream APIs filter out decoys (:target == false) before calling this. If a :target column is present, rows with target == false are dropped defensively.\n\nRequired columns\n\nproteinresults: :protein, `scorecol, and either:msfileidxor:file_name`.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.create_global_results_df-Tuple{DataFrames.DataFrame}","page":"Home","title":"PioneerEntrapment.create_global_results_df","text":"create_global_results_df(prec_results::DataFrame; score_col::Symbol=:global_prob) -> DataFrame\n\nBuild a per-precursor global table by selecting, for each :precursor_idx, the row with the best available score_col across files.\n\nIf :ms_file_idx exists, the returned rows have :ms_file_idx = 0. If only :file_name exists, a synthetic \"global\" file name is assigned.\n\nRequired columns\n\nprecresults: `:precursoridx,:msfileidx(or:filename),scorecol`\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.generate_markdown_report-Tuple{DataFrames.DataFrame, DataFrames.DataFrame, Dict, Dict, Vector{Tuple{Symbol, Symbol}}, Vector, Int64, String, String}","page":"Home","title":"PioneerEntrapment.generate_markdown_report","text":"generate_markdown_report(prec_results, library_precursors, comparison_results,\n                       calibration_results, score_qval_pairs, method_types,\n                       original_rows, output_dir, output_path)\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.getModKey-Tuple{AbstractString}","page":"Home","title":"PioneerEntrapment.getModKey","text":"getModKey(mod_string::AbstractString) -> String\n\nExtract a canonical modification key from a modification annotation string.\n\nThe function searches for substrings of the form (pos,AA,MODNAME) and returns the sorted, semicolon-delimited list of MODNAME values. This allows grouping precursors that differ only by order or position of identical modifications.\n\nArguments\n\nmod_string: Freeform modification annotation containing tokens like (5,M,Oxidation).\n\nReturns\n\nA string such as \"Acetyl;Oxidation\". Returns \"\" if no mods are found.\n\nExample     julia> getModKey(\"(5,M,Oxidation)(1,K,Acetyl)\")     \"Acetyl;Oxidation\"\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.get_combined_efdr","page":"Home","title":"PioneerEntrapment.get_combined_efdr","text":"get_combined_efdr(score, original_target_score, entrapment_label, qval, [r])\n\nConvenience wrapper to build a CombinedEFDR method and compute EFDR. original_target_score is accepted for symmetry but not used by Combined.\n\n\n\n\n\n","category":"function"},{"location":"#PioneerEntrapment.get_complement_score-Tuple{DataFrames.DataFrame, Int64}","page":"Home","title":"PioneerEntrapment.get_complement_score","text":"get_complement_score(prec_results::DataFrame, row_idx::Int; score_col=:score) -> Float64\n\nReturn the best score of the complementary entry within the same entrapment pair.\n\nGiven a row index, this scans all rows with the same :entrapment_pair_id and returns the maximum score among those rows excluding row_idx itself. If the pair ID is missing or no complement exists, returns 0.0.\n\nRequired columns\n\nprecresults: `:entrapmentpairid,scorecol`\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.get_paired_efdr","page":"Home","title":"PioneerEntrapment.get_paired_efdr","text":"get_paired_efdr(score, original_target_score, entrapment_label, qval, [r])\n\nConvenience wrapper to build a PairedEFDR method and compute EFDR. Use when you already have aligned entrapment and original target scores.\n\n\n\n\n\n","category":"function"},{"location":"#PioneerEntrapment.plot_efdr_comparison_replicates-Tuple{Vector{DataFrames.DataFrame}, Symbol, Symbol}","page":"Home","title":"PioneerEntrapment.plot_efdr_comparison_replicates","text":"Plot EFDR comparison across multiple replicate DataFrames on a single plot. Colors are per method; linestyles per replicate.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.run_both_analyses-Tuple{}","page":"Home","title":"PioneerEntrapment.run_both_analyses","text":"run_both_analyses(; precursor_results_path::AbstractString,\n                    library_precursors_path::AbstractString,\n                    protein_results_path::AbstractString,\n                    output_dir::AbstractString = \"efdr_out\",\n                    r_lib::Float64 = 1.0,\n                    plot_formats::Vector{Symbol} = [:png, :pdf],\n                    use_fast_paired::Bool = true,\n                    verbose::Bool = true)\n\nRun both the precursor-level and protein-level analyses. Returns a NamedTuple with both results, writing outputs into output_dir/precursor and output_dir/protein.\n\nParameters\n\nusefastpaired: If true (default), use fast O(n log n) implementation for PairedEFDR. If false, use standard O(n²) implementation.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.run_efdr_analysis-Tuple{String, String}","page":"Home","title":"PioneerEntrapment.run_efdr_analysis","text":"run_efdr_analysis(prec_results_path::String, library_precursors_path::String;\n                  output_dir::String=\"efdr_out\",\n                  method_types=[CombinedEFDR, PairedEFDR],\n                  score_qval_pairs=[(:global_prob, :global_qval), (:prec_prob, :qval)],\n                  r_lib::Float64=1.0,\n                  plot_formats=[:png, :pdf],\n                  use_fast_paired::Bool=true,\n                  verbose::Bool=true)\n\nRun empirical FDR analysis on precursor-level data with entrapment sequences. Accepts Arrow/CSV inputs for convenience.\n\nParameters\n\nusefastpaired: If true (default), use fast O(n log n) implementation for PairedEFDR. If false, use standard O(n²) implementation.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.run_efdr_plots-Tuple{String, String}","page":"Home","title":"PioneerEntrapment.run_efdr_plots","text":"run_efdr_plots(results_dir::String, library_path::String; output_dir=joinpath(results_dir, \"efdr_out\"), r_lib=1.0, paired_stride=5, plot_formats=[:png,:pdf], use_fast_paired=true, verbose=true)\n\nConvenience entry point that looks for standard filenames in results_dir:\n\nprecursors_long.arrow (or .tsv) for precursor-level\nproteingroupslong.arrow (or .tsv) for protein-level\n\nRuns the appropriate analyses, writing outputs into output_dir (or subfolders if both).\n\nParameters\n\nusefastpaired: If true (default), use fast O(n log n) implementation for PairedEFDR. If false, use standard O(n²) implementation.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.run_efdr_replicate_plots-Tuple{Vector}","page":"Home","title":"PioneerEntrapment.run_efdr_replicate_plots","text":"run_efdr_replicate_plots(replicates; output_dir=\"efdr_out\", score_qval_pairs=[(:global_prob, :global_qval), (:prec_prob, :qval)], r_lib=1.0, paired_stride=5, plot_formats=[:png,:pdf], use_fast_paired=true, verbose=true)\n\nCompute EFDR for multiple (precursorresultspath, libraryprecursorspath) replicates and plot on shared figures.\n\nreplicates is a Vector of NamedTuples with fields:\n\nprecursor_results_path::String\nlibrary_precursors_path::String\nlabel::String (optional, used in plot legend)\n\nParameters\n\nusefastpaired: If true (default), use fast O(n log n) implementation for PairedEFDR. If false, use standard O(n²) implementation.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.run_protein_efdr_analysis-Tuple{String}","page":"Home","title":"PioneerEntrapment.run_protein_efdr_analysis","text":"run_protein_efdr_analysis(protein_results_path::String;\n                          output_dir::String=\"efdr_out\",\n                          method_types=[CombinedEFDR, PairedEFDR],\n                          score_qval_pairs=[(:global_pg_score, :global_qval), (:pg_score, :qval)],\n                          r_lib::Float64=1.0,\n                          plot_formats=[:png, :pdf],\n                          use_fast_paired::Bool=true,\n                          verbose::Bool=true)\n\nParameters\n\nusefastpaired: If true (default), use fast O(n log n) implementation for PairedEFDR. If false, use standard O(n²) implementation.\n\n\n\n\n\n","category":"method"},{"location":"#PioneerEntrapment.CombinedEFDR","page":"Home","title":"PioneerEntrapment.CombinedEFDR","text":"CombinedEFDR\n\nStandard combined empirical FDR method that estimates FDR from counts of targets and entrapments seen up to a given score/q-value threshold.\n\nFields\n\nscore::Vector{T}: The score used for ordering (higher is better).\noriginaltargetscore::Vector{T}: Unused by this method; present for API consistency.\nentrapment_label::Vector{I}: 0 for targets; non-zero for entrapments.\nqval::Vector{T}: q-value or confidence score used for tie-breaking.\nr::T: Target:entrapment ratio factor (typically 1.0 for balanced design).\n\n\n\n\n\n","category":"type"},{"location":"#PioneerEntrapment.PairedEFDR","page":"Home","title":"PioneerEntrapment.PairedEFDR","text":"PairedEFDR\n\nPaired empirical FDR method that accounts for within-pair relationships between an entrapment and its original target score. Uses additional terms to penalize entrapments that either exceed their target or appear when a target is absent at a given cutoff.\n\nFields\n\nscore::Vector{T}: The entrapment/test score.\noriginaltargetscore::Vector{T}: The score of the original target partner.\nentrapment_label::Vector{I}: 0 for targets; non-zero for entrapments.\nqval::Vector{T}: q-value or confidence for ordering/tie-breaks.\nr::T: Target:entrapment ratio factor.\n\n\n\n\n\n","category":"type"},{"location":"#Example:-Julia-REPL-on-local-data","page":"Home","title":"Example: Julia REPL on local data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run EFDR from a Julia REPL using a .poin library directory (auto-detects precursors_table.arrow) and a results folder with precursors_long.arrow.","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd /Users/nathanwamsley/Projects/PioneerEntrapment.jl\njulia --project=. -q","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.instantiate()\nusing PioneerEntrapment\n\nlibrary = \"/Users/nathanwamsley/Data/SPEC_LIBS/entrapment_08-20-2025/altimeter_yeast_len7o40_ch2o3_mc1_MTACAstral_Aug302025_entrapR1.poin/altimeter_yeast_len7o40_ch2o3_mc1_MTACAstral_Aug302025_entrapR1.poin.poin\"\nprecursors = \"/Users/nathanwamsley/Data/MS_DATA/MTAC_Y_Astral/YEAST_3MIN/MTAC_Y_entrapR1_feature-fix-mbr_D_08-30-2025/precursors_long.arrow\"\n# If TSV instead, use:\n# precursors = \"/Users/nathanwamsley/Data/MS_DATA/MTAC_Y_Astral/YEAST_3MIN/MTAC_Y_entrapR1_feature-fix-mbr_D_08-30-2025/precursors_long.tsv\"\nout = \"/Users/nathanwamsley/Data/MS_DATA/MTAC_Y_Astral/YEAST_3MIN/MTAC_Y_entrapR1_feature-fix-mbr_D_08-30-2025/efdr_out\"\n\nrun_efdr_analysis(precursors, library;\n    output_dir=out,\n    r_lib=1.0,\n    paired_stride=10,      # sampling stride for paired EFDR\n    plot_formats=[:png, :pdf],\n    verbose=true,\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Notes","category":"page"},{"location":"","page":"Home","title":"Home","text":"Passing the library as the .poin.poin directory is supported; the loader resolves precursors_table.arrow internally.\nPrefer precursors_long.arrow when available; .tsv also works.","category":"page"},{"location":"#Live-Reload-with-Revise","page":"Home","title":"Live Reload with Revise","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg; Pkg.add(\"Revise\")\nusing Revise\nusing PioneerEntrapment\n\nRevise.includet(\"scripts/replicate_plot_example.txt\")\n\n# after edits in src/, just call again\nRevise.includet(\"scripts/replicate_plot_example.txt\")","category":"page"},{"location":"#Multi-run-comparison-(replicates)","page":"Home","title":"Multi-run comparison (replicates)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plot EFDR from multiple runs in a single figure (one color per method, solid lines per replicate).","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PioneerEntrapment\n\nlibrary = \"/path/to/library/.poin/.poin\"\nrep1 = \"/path/to/run1/precursors_long.arrow\"\nrep2 = \"/path/to/run2/precursors_long.arrow\"\n\nreplicates = [\n  (precursor_results_path=rep1, library_precursors_path=library, label=\"run1\"),\n  (precursor_results_path=rep2, library_precursors_path=library, label=\"run2\"),\n]\n\nrun_efdr_replicate_plots(replicates;\n  output_dir=\"./efdr_compare\",\n  r_lib=1.0,\n  paired_stride=10,\n  plot_formats=[:png, :pdf],\n  verbose=true,\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the output directory for files named like efdr_comparison_replicates_global_prob.png.","category":"page"},{"location":"#CLI-via-config","page":"Home","title":"CLI via config","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# JSON\nbin/pioneer-entrapment --mode replicates \\\n  --replicates-config scripts/replicates_example.json \\\n  --outdir ./efdr_compare --paired-step 10\n\n# YAML (requires YAML.jl)\nbin/pioneer-entrapment --mode replicates \\\n  --replicates-config scripts/replicates_example.yaml \\\n  --outdir ./efdr_compare --paired-step 10","category":"page"},{"location":"","page":"Home","title":"Home","text":"JSON expects an array of objects. YAML expects a top-level replicates: list with objects containing precursor_results_path, library_precursors_path, and optional label.","category":"page"},{"location":"#CLI-(replicates)-with-TOML-config","page":"Home","title":"CLI (replicates) with TOML config","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JULIA_PROJECT=. bin/pioneer-entrapment --mode replicates \\\n  --replicates-config scripts/replicates_example.toml \\\n  --outdir ./efdr_compare --paired-step 10 --plot-formats png,pdf","category":"page"},{"location":"#Folder-convenience-(both-precursor-and-protein)","page":"Home","title":"Folder convenience (both precursor and protein)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Analyze a results folder with standard filenames (precursorslong.arrow and/or proteingroups_long.arrow):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PioneerEntrapment\nrun_efdr_plots(\"/path/to/results\", \"/path/to/library/.poin/.poin\";\n  output_dir=joinpath(\"/path/to/results\", \"efdr_out\"),\n  paired_stride=10,\n  plot_formats=[:png, :pdf],\n  verbose=true,\n)","category":"page"},{"location":"#Vector-friendly-PDF-output","page":"Home","title":"Vector-friendly PDF output","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plots.jl + GR: text set to be editable (GR.setcharquality(0)).\nDefault font is Helvetica; override with using Plots; Plots.default(fontfamily=\"Arial\") or pass fontfamily to plot calls.\nInclude :pdf in plot_formats to save vector PDFs.","category":"page"}]
}
